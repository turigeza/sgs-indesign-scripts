/*******************************************************************************

		Name:           ZDeflate
		Desc:           Encapsulate the deflate (compression) algorithm.
		Path:           /etc/$$.ZDeflate.jsxlib
		Require:        ---
		Encoding:       ÛȚF8
		Core:           NO
		Kind:           Module.
		API:            =run() onEngine() zlib()
		DOM-access:     NO
		Todo:           ---
		Created:        180914 (YYMMDD)
		Modified:       190420 (YYMMDD)

*******************************************************************************/

;$$.hasOwnProperty('ZDeflate') || eval(__(MODULE, $$, 'ZDeflate', 190420, 'run'))


	//==========================================================================
	// NOTICE
	//==========================================================================

	/*

	[REF] http://www.onicos.com/staff/iz/amuse/javascript/expert/
	
	Both the `ZDeflate` and `ZInflate` modules are based on Masanao Izumo's
	implementation -- www.onicos.com/staff/iz/amuse/javascript/expert/ --
	ported into ExtendScript. Many tests have been done and many tricks have
	been applied to get the most efficient inflate/deflate processes in
	IdExtenso.
	
	These modules are fine for processing *small* data streams (say < 50KB)
	in a decent time; then avoiding the use of external tools, libraries, or
	DOM methods. If you need to zip/unzip *larger* files from InDesign, turn
	to the DOM methods `app.packageUCF()` and `app.unpackageUCF()`.

	`ZDeflate` and `ZInflate` are independent, so if your project only wants
	to compress strings, you can include `$$.ZDeflate.jsxlib` alone.

	COMPRESSION
	
	Use `$$.ZDeflate(myOriginalString)` to get the compressed string using
	the default options (level=6 ; input buffer=32KB ; small memory model.)
	To refine this, cf detail in the `run` method.
	
	[REM] The `run` method is automatic, that is, `$$.ZDeflate()` is the
	shortcut of `$$.ZDeflate.run()`

	*/

	//==========================================================================
	// CONSTANT DATA
	//==========================================================================

	[PRIVATE]
	
	({
		// Bit-Length-Order (shared w/ inflate.)
		//----------------------------------
		BLOR: Array( 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ),
		BLSZ: 19,

		// Enums.
		//----------------------------------
		ESTO: 0,                                  // Stored block.
		ESTA: 1,                                  // Static trees.
		EDYN: 2,                                  // Dynamic trees.

		// Constants.
		//----------------------------------
		WMEM: 32768/4,                            // Base window size (2^13) ; must be 2^n.
		DLIT: 257,                                // 1 + (Number of literals.)
		MMIN: 3,                                  // Min. match length ; the max. length is fixed to 258.
		// ---
		ZR36: 16,                                 // REP_3_6      (code for 3 <= count <= 6)
		ZR3A: 17,                                 // REPZ_3_10    (code for 3 <= count <= 10)
		ZR11: 18,                                 // REPZ_11_138  (code for 11 <= count <= 138)

		// Default compression settings.
		//----------------------------------
		FULL: true,                               // Full search.
	})
	
	//==========================================================================
	// BASIC TOOLS
	//==========================================================================
	
	[PRIVATE]
	
	({
		REVB: function(/*int32*/code,/*0..32*/n,  r)
		//----------------------------------
		// (Bit-Reverse.) Reverse the first `n` bits from `code`.
		{
			r = 0;
			do{ r |= 1&code ; code >>= 1 ; r <<= 1 } while( 0 < --n );
			return r >> 1;
		},

		HASH: function(/*int*/x,/*int*/y)
		//----------------------------------
		// (Hash.) Hash routine.
		// => int
		{
			return callee.MASK & ( ( x << callee.SHFT ) ^ ( 0xFF & y ) );
		}
		.setup({ MASK:-1, SHFT:-1 }),

		INSH: function(/*arr*/win,/*arr&*/dic,/*uint*/beg,/*fct*/hash,  x,r)
		//----------------------------------
		// (Insert-Hash.) Insert the string in the dictionary and set match head
		// to the previous head of the hash chain (the most recent string with
		// same hash key). Return the hash head.
		// [REM] All calls to this method are made with consecutive input chars
		// and the first MIN_MATCH bytes of the string are valid (except for the
		// last MIN_MATCH-1 bytes of the input file).
		// => uint
		{
			x = callee.DX + ( callee.POS = hash(callee.POS, win[callee.DW+beg]) );
			
			r = dic[callee.WMASK&beg] = dic[x];
			dic[x] = beg;
			return r;
		}
		.setup({ DX:µ['~'].WMEM, DW:-1+µ['~'].MMIN, POS:0, WMASK:-1+µ['~'].WMEM }),

		READ: function(/*arr&*/buf,/*int*/off,/*int*/len,  p,s,n,i)
		//----------------------------------
		// (Read-to-Buffer.) Read string data into the buffer and return the
		// number of chars actually read (at most `len`.)
		// => int
		{
			for( p=callee.POS, n=(s=callee.DATA).length, i=-1 ; ++i < len && p < n ; buf[i+off]=255&s.charCodeAt(p++) );
			return (callee.POS=p), i;
		}
		.setup({ DATA:'', POS:0, TIMER:0 }),

		OUTB: function(/*int8*/x,  a,dp,n,q,t,i)
		//----------------------------------
		// (Output-Byte.) Output a 8-bit value into the queue-buffer.
		// => undef
		{
			(a=callee.OBUF)[ (dp=callee.OFF) + callee.POS++ ] = x;
			if( (n=callee.ODIM) != dp + callee.POS ) return;

			// Queue.
			// ---
			(q=callee.FREE) ? (callee.FREE=q.next) : (q={ ptr:Array(n) });
			q.next = q.size = q.off = 0;
			callee.TAIL = (t=callee.TAIL) ? (t.next=q) : (callee.HEAD=q);

			for( n=q.size=callee.POS-dp, i=-1 ; ++i < n ; q.ptr[i]=a[i+dp] );

			callee.POS = callee.OFF = 0;
		}
		.setup({ OBUF:false, ODIM:0, OFF:0, POS:0, HEAD:false, TAIL:false, FREE:false }),
		
		ADLR: function(/*str*/s,/*?uint16*/seed,  a,b,n,i,mn)
		//----------------------------------
		// (Adler32.) [ADD190420]
		// => uint32
		{
			( seed && 'number'==typeof seed ) || (seed=0);
			a = seed ? (0xFFFF&seed) : 1;
			b = seed ? (seed >>> 16) : 0;

			for( mn=0, n=s.length, i=-1 ; ++i < n ; )
			{
				3850 > (mn=n-i) || (mn=3850);
				for( mn+=i ; i < mn ; b += (a+=0xFF&s.charCodeAt(i++)) );
				a = (15*(a>>>16)+(a&65535));
				b = (15*(b>>>16)+(b&65535));
			}

			return ((b%65521) << 16) | (a%65521);
		},

	})

	//==========================================================================
	// SLIDING WINDOW
	//==========================================================================

	[PRIVATE]
	
	({

		FILL: function(/*uint*/idx,/*fct*/fRead,/*?int*/mPos,  q,eof,DLT,WSZ,MNL,IMX,HSZ,w,dic,lka,i,t,x)
		//----------------------------------
		// (Fill-Window.) Fill the window when the lookahead becomes insufficient.
		// Updates start index with respect to the supplied idx. Updates lookahead
		// (LOOK), and sets EOF if end of input. (At least two bytes are read.)
		// Return updated match pos.
		// => int [UPDATED MATCH START]
		{
			(q=callee).IDX = idx;
			if( eof=q.EOF ) return mPos||0;

			DLT = q.DELTA;
			WSZ = q.WDIM;
			MNL = q.MIN_LOOK;
			IMX = q.IDX_MAX;
			HSZ = q.H_SIZE;

			lka = q.LOOK;
			for( w=q.WIN, dic=q.PRV ; lka < MNL && (!eof) ; ( eof = 0 >= (i=fRead(w,idx+lka,x)) ) || (lka+=i) )
			{
				if( -1 == (x=WSZ-lka-idx) ){ x--; continue; }
				if( idx < IMX ) continue;

				// Shift.
				// ---
				for( i=-1 ; ++i < DLT ; w[i]=w[i+DLT] );
				mPos -= DLT;
				q.IDX = (idx -= DLT);
				q.START -= DLT;

				for( i=-1 ; ++i < HSZ ; (t=-DLT+dic[i+DLT]), (dic[i+DLT] = 0 <= t ? t : 0) );
				for( i=-1 ; ++i < DLT ; (t=-DLT+dic[i]),     (dic[i]     = 0 <= t ? t : 0) );

				x += DLT;
			}
			q.LOOK = lka;

			eof && (q.EOF=true);
			return mPos||0;
		}
		.setup
		({
			DELTA:  µ['~'].WMEM,        // Local copy of window mem (avoid context dependency.)
			WDIM:   2*µ['~'].WMEM,      // Total Window size.
			MIN_LOOK: -1,               // fed from onEngine
			IDX_MAX:  -1,               // fed from onEngine
			// ---
			H_SIZE:   -1,               // fed from DEFL
			// ---
			EOF:   true,
			WIN:   false,
			PRV:   false,
			START: 0,
			IDX:   0,
			LOOK:  0,
		}),

	})
	
	//==========================================================================
	// OUTPUT ROUTINES
	//==========================================================================

	[PRIVATE]
	
	({

		OUTS: function(/*int16*/x,  fOB,dp,a)
		//----------------------------------
		// (Output-Short.) Output a 16-bit value [LO,HI].
		{
			x &= 0xFFFF;
			fOB = this.OUTB;

			if( 2+(dp=fOB.OFF)+fOB.POS < fOB.ODIM )
			{
				a = fOB.OBUF;
				a[dp + fOB.POS++] = 0xFF&x;
				a[dp + fOB.POS++] = x >>> 8;
			}
			else 
			{
				fOB(0xFF&x);
				fOB(x >>> 8);
			}
		},

		QCPY: function(/*arr&*/buf,/*int*/off,/*int*/bfSize,  fOB,H,n,i,j,p,t,a)
		//----------------------------------
		// (Queue-Copy.) Copy the queue in this buffer at offset `off`.
		// => uint
		{
			fOB = this.OUTB;

			for( H=fOB.HEAD, n=0 ; H && 0 < (i=bfSize-n) ; n+=i )
			{
				i > H.size  && (i=H.size);

				for( p=off+n, t=H.off, j=-1 ; ++j < i ; buf[p+j]=H.ptr[t+j] );

				H.off += i;
				if( H.size -= i ) continue;

				fOB.HEAD = H = (t=H).next;
				t.next = fOB.FREE;
				fOB.FREE = t;
			}

			t = fOB.POS - fOB.OFF;
			if( n == bfSize || 0 >= t ){ return n; }

			(i=bfSize-n) > t && (i=t);

			for( a=fOB.OBUF, t=fOB.OFF, p=off+n, j=-1 ; ++j < i ; buf[p+j] = a[t+j] );
			n += i;
			fOB.POS == (fOB.OFF+=i) && (fOB.POS=fOB.OFF=0);

			return n;
		},

		SNDB: function(/*int|obj*/x,/*int|falsy*/n,  d,bs)
		//----------------------------------
		// (Send-Bits.) If `n` is falsy, `x` MUST be a code node and then the pair
		// ( x=x.fc , n=x.dl ) is used instead.
		// [REM] callee.BDIM (size of the bit buffer) can be 24 (?)
		// => <this>
		{
			n || ((n=x.dl),(x=x.fc));

			callee.BBUF |= (x << (bs=callee.BSHIFT));
			if( bs <= (d=callee.BDIM-n) ){ callee.BSHIFT+=n; return this; }

			this.OUTS(callee.BBUF);
			callee.BBUF = x >> (callee.BDIM - bs);
			callee.BSHIFT -= d;
			return this;
		}
		.setup({ BBUF:0, BDIM:16, BSHIFT:0, }),

		SEND: function(/*tree*/T,/*int*/maxCode,/*tree*/BL,  nx,pv,mx,mn,k36,k3A,k11,n,i,cur)
		//----------------------------------
		// (Send-Tree.) Send a literal or distance tree in compressed form,
		// using the codes from BL tree.
		// => undef
		{
			(nx=T[0].dl) ? ((mx=7),(mn=4)) : ((mx=138),(mn=3));

			k36 = this.ZR36; // 16
			k3A = this.ZR3A; // 17
			k11 = this.ZR11; // 18

			for( n=0, pv=i=-1 ; ++i <= maxCode ; )
			{
				cur = nx;
				nx = T[1+i].dl;
				if( ++n < mx && cur == nx ) continue;

				if( n < mn )
				{
					do{ this.SNDB(BL[cur]) }while( --n );
				}
				else if( cur )
				{
					cur != pv && (this.SNDB(BL[cur]),--n);
					this.SNDB(BL[k36]).SNDB(-3+n, 2);
				}
				else if( n <= 10 )
				{
					this.SNDB(BL[k3A]).SNDB(-3+n, 3);
				}
				else 
				{
					this.SNDB(BL[k11]).SNDB(-11+n, 7);
				}

				n = 0;
				pv = cur;
				mn = 3;
				mx = (0==nx)*138 || (cur==nx)*6 || (++mn,7);
			}
		},

	})

	//==========================================================================
	// INNER PROCESS
	//==========================================================================

	[PRIVATE]
	
	({

		MTCH: function(/*int*/curMatch,/*uint*/prvLen,/*cnst*/mxDIST,/*fct*/FW,  iBEG,iSUP,rMAX,mLIM,dic,MSK,len,i,w,dx,bef,end,sm,m,t)
		//---------------------------------- (70%)
		// (Longest-Match-Algo.) Set match start to the longest match starting at
		// the given string and return its length. Matches shorter or equal to
		// previous length are discarded, in which case the result is equal to prev
		// length and match start is garbage.
		// ---
		// curMatch :: head of the hash chain for the current string (strstart) and its
		//             distance is <= mxDIST, and prev_length >= 1
		// prvLen   :: previous match length.
		// => int
		{
			// iBEG  :: Init scan index.
			// iSUP  :: Sup scan index (iBEG+258.)
			// rMAX  :: Max result length (<= 258) -- depending on FULL and `nice` setting.
			// ---
			iSUP = 258+(iBEG=FW.IDX);
			rMAX = this.FULL ? 258 : callee.NICE;

			// Stop when current match becomes <= mLIM.
			// Prevent matches with the string of win-index 0.
			// [REM] mxDIST :: 32K - (1 + 258 + MMIN=3 )
			// ---
			0 < (mLIM=iBEG-mxDIST) || (mLIM=0);
			
			// len :: max hash chain length.
			// ---
			len = callee.MAX_CHAIN_LEN;
			
			// dx :: best match length so far (init. to the prev length.)
			// ---
			callee.GOOD <= (dx=prvLen) && (len >>= 2);                // already a good match => reduce length to save time

			w = FW.WIN;
			bef = w[-1+iBEG+dx];                                      // bef :: value at endscan-1
			end = w[iBEG+dx];                                         // end :: value at endscan
			sm = this.DINT.MATCH_START;

			for( dic=FW.PRV, MSK=callee.MASK, i=iBEG, t=true ; len-- && t ; t = mLIM < (curMatch=dic[MSK&curMatch]) )
			{
				m = curMatch;
				if( end!=w[m+dx] || bef!=w[-1+m+dx] || w[m]!=w[i] || w[++m]!=w[1+i] ) continue;

				for(
					i+=2, ++m ;
					w[++i]==w[++m] && w[++i]==w[++m] && w[++i]==w[++m] && w[++i]==w[++m] &&
					w[++i]==w[++m] && w[++i]==w[++m] && w[++i]==w[++m] && w[++i]==w[++m] &&
					i < iSUP ;
					);

				t = i - iBEG;                         // length of the current match
				i = iBEG;

				if( t <= dx ) continue;               // too small
				sm = curMatch;
				if( (dx=t) >= rMAX ) break;           // long enough.
				
				bef = w[-1+iBEG+dx];
				end = w[iBEG+dx];
			}

			this.DINT.MATCH_START = sm;
			return dx;
		}
		.setup({ MASK:µ['~'].INSH.WMASK, GOOD:-1, NICE:-1 }),

		IDSC: function(/*obj&*/desc,/*uint|false*/iDyn,/*uint|false*/iSta,/*arr*/xBits,/*uint*/xb,/*uint*/itm,/*uint*/mxLen,/*uint*/mxCde,  a,n,i)
		//----------------------------------
		// (Init-Descriptor.) Initialize a descriptor and create its inner
		// trees (empty) with respect to the lengths iDyn and iStat.
		// ---
		// => callee
		{
			a = desc.dyna = (n=iDyn||0) ? Array(n) : false;
			for( i=-1 ; ++i < n ; a[i]={ fc:0, dl:0 } );

			a = desc.stat = (n=iSta||0) ? Array(n) : false;
			for( i=-1 ; ++i < n ; a[i]={ fc:0, dl:0 } );
			
			desc.xbits = xBits||false;

			desc.xbase = xb||0;
			desc.items = itm||0;
			desc.maxlen = mxLen||0;
			desc.maxcode = mxCde||0;

			return callee;
		},

		IBLK: function(/*false|obj&*/LD,/*?obj&*/DD,/*?obj&*/BD,  F,a,o,n,i)
		//----------------------------------
		// (Init-Block.) Initialize a new block. If LD is false -> full init.
		// => undef
		{
			if( false===LD )
			{
				F = this.FLSH;
				LD = F.LI_DESC;
				DD = F.DI_DESC;
				BD = F.BL_DESC;

				// Reset all descriptors (fresh arrays.)
				// ---
				this.IDSC
				(LD, this.HUFF.HEAP_SIZE, 2+this.COMP.LC_OFF, this.COMP.X_LENG, this.DLIT, this.COMP.LC_OFF, 15, 0)
				(DD, 1+2*this.COMP.DB_DIM,  this.COMP.DB_DIM, this.COMP.X_DIST, 0,         this.COMP.DB_DIM, 15, 0)
				(BD, 1+2*this.BLSZ,                    false, this.COMP.X_BL,   0,         this.BLSZ,         7, 0);

				for( a=this.GBIT.BL_COUNT, i=-1 ; ++i <= 15 ; a[i]=0 );
				o = LD.stat;
				for( n=0 ; n <= 143 ; (o[n++].dl=8), a[8]++ );
				for(     ; n <= 255 ; (o[n++].dl=9), a[9]++ );
				for(     ; n <= 279 ; (o[n++].dl=7), a[7]++ );
				for(     ; n <= 287 ; (o[n++].dl=8), a[8]++ );
				this.GCOD(o, 1+this.COMP.LC_OFF, a);

				o = DD.stat;
				for( F=this.REVB, n=-1 ; ++n < this.COMP.DB_DIM ; (o[n].dl=5), o[n].fc=F(n,5) );
			}

			// Dynamic init.
			// ---
			for( a=BD.dyna, n=this.BLSZ,        i=-1 ; ++i < n ; a[i].fc=0 );
			for( a=DD.dyna, n=this.COMP.DB_DIM, i=-1 ; ++i < n ; a[i].fc=0 );
			for( a=LD.dyna, n=this.COMP.LC_OFF, i=-1 ; ++i < n ; a[i].fc=0 );
			a[256].fc = 1; // End block

			// Reset scalars.
			// ---
			o = this.FREQ;
			o.FLAG_BIT= 1;
			o.LAST_LITR = o.LAST_DIST = o.LAST_FLAG = o.FLAG_VAL = 0;
			this.GBIT.STAT_LEN = this.GBIT.OPT_LEN = 0;
		},

		DOWN: function(/*tree*/T,/*int*/hid,/*heap&*/HP,/*arr*/DP,/*uint*/hLen,  v,i,x,y,xf,yf)
		//----------------------------------
		// (Down-Heap.) Restore the heap property by moving down the tree starting at `hid`,
		// exchanging a node with the smallest of its children if necessary, stopping when
		// the heap property is re-established (each parent smaller than its children.)
		// => undef
		{
			// T        :: the tree to restore
			// hid      :: node to move down
			// hid << 1 :: left son of hid
			// HP       :: heap structure.
			// DP       :: associated depth array.

			for( v=HP[hid], i=hid << 1 ; i <= hLen ; i <<= 1 )
			{
				// Set i to the smallest of the two children. (Use the depth tree as tie
				// breaker when subtrees have equal frequency; minimizes the worst case length.)
				// ---
				i < hLen
				&& ( (xf=T[x=HP[1+i]].fc) < (yf=T[y=HP[i]].fc) || ( xf==yf && DP[x] <= DP[y] ) )
				&& ++i;

				// Exit if v is smaller than both children.
				// ---
				if( (xf=T[x=v].fc) < (yf=T[y=HP[i]].fc) || ( xf==yf && DP[x] <= DP[y] ) ) break;

				// Exchange v with the smallest child.
				// ---
				HP[hid] = HP[i];
				hid = i;
			}

			HP[hid] = v;
		},

		GCOD: function(/*tree&*/T,/*int*/maxCode,/*uint[16]*/BLC,  q,c,i,F)
		//----------------------------------
		// (Gen-Codes.) Generate codes for that tree and bit counts (needn't be
		// optimal.) `maxCode` is the largest code with nonzero frequency ;
		// the array `BLC` already contains bit-length counts for that tree,
		// the `.dl` key is already set for all elements. This function then
		// sets the `.fc` key (code) for all elements of nonzero code length.
		// => undef
		{
			// Distrib counts are first used to generate codes w/o bit reversal.
			// [REM] Optim: the cached array (length=16) is filled at each call.
			// ---
			for( q=callee.Q, c=i=0 ; ++i <= 15 ; q[i]=c=((c + BLC[-1+i]) << 1) );
			
			// Reverse the bits.
			// ---
			for( F=this.REVB, i=-1 ; ++i <= maxCode ; (c=T[i].dl)&&(T[i].fc=F(q[c]++,c)) );
		}
		.setup({ Q:Array(16) }),

		GBIT: function(/*obj&*/desc,/*heap*/HP,/*uint*/h,  q,hSup,DT,XT,ST,b,c,l,n,m,i,x,t,ovf)
		//----------------------------------
		// (Gen-Bit-Lengths.) Compute the optimal bit lengths for a tree and
		// update the total bit length for the current block.
		// [REM] Frequencies and parents are already set; heap[heapMax] and above
		// have already been sorted by increasing frequency. This function then
		// sets the field size to the optimal bit length, and makes `BL_COUNT`
		// host the frequencies for each bit length. The optimal length is also
		// updated; and static length is updated if stat is not null.
		// => uint[16]  (BL_COUNT)
		{
			q = callee.BL_COUNT;

			hSup = this.HUFF.HEAP_SIZE
			HP = this.HUFF.HEAP;
			
			DT = desc.dyna;
			XT = desc.xbits;
			ST = desc.stat;

			// Preset counts to zero.
			// ---
			for( i=-1 ; ++i <= 15 ; q[i]=0 );

			// Root of the heap.
			// ---
			DT[HP[h]].dl = 0;

			// First pass: compute the optimal bit lengths (which
			// may overflow in the case of the bit length tree.)
			// ovf :: number of elements with bit length too large.
			// h   :: heap index
			// ---
			for( b=desc.xbase, c=desc.maxcode, l=desc.maxlen, ovf=0 ; ++h < hSup ; )
			{
				l < (i=1+DT[DT[n=HP[h]].dl].dl) && ((i=l),++ovf);
				
				DT[n].dl = i;                     // Overwrite DT[n].dl (no longer needed.)
				if( n > c ) continue;             // Not a leaf node.

				q[i]++;                          // Increase counter.
				x = n >= b ? XT[n-b] : 0;
				callee.OPT_LEN += (t=DT[n].fc)*(i+x);       // Update the opt length.
				ST && (callee.STAT_LEN += t*(x+ST[n].dl));   // Update the static length (if static tree.)
			}
			if( !ovf ) return q;

			// [REF] This happens for example on obj2 and pic of the Calgary corpus.

			// Find the 1st bit length which could increase.
			// ---
			for( ; 0 < ovf ; ovf -= 2 )
			{
				for( i=-1+l ; !q[i] ; i-- );
				q[i]--;
				q[1+i] += 2;
				q[l]--;
			}

			// Recompute all bit lengths, scanning in increasing frequency.
			// [REM] `h` is still equal to HEAP_SIZE. (It is simpler to reconstruct all
			// lengths instead of fixing only the wrong ones.)
			// ---
			for( i=1+l ; --i ; )
			{
				for( n=q[i] ; n ; )
				{
					if( c < (m=HP[--h]) ) continue;
					if( i != (t=DT[m].dl) )
					{
						callee.OPT_LEN += (i-t)*DT[m].fc;
						DT[m].fc = i;
					}
					n--;
				}
			}
			
			return q;
		}
		.setup({ BL_COUNT:Array(16), OPT_LEN:-1, STAT_LEN:-1 }),

		HUFF: function(/*obj&*/desc,  HP,DP,Dyn,Sta,n,o,hLen,h,c,i,j)
		//----------------------------------
		// (Build-Huffman-Tree.) Construct one Huffman tree and assigns the code bit
		// strings and lengths. Update the total bit length for the current block.
		// [REM] The frequency field is already set for all tree elements. This
		// function sets the size and code fields to the optimal bit length and
		// corresponding code. It also updates the opt. length, and static length
		// if static stree is not null. `maxcode` is set too.
		// => undef
		{
			HP = callee.HEAP;
			DP = callee.DEPTH;
			
			Dyn = desc.dyna;
			Sta = desc.stat;
			n =   desc.items;

			// Build the initial heap, with least frequent element in HP[SMALLEST].
			// Children of HP[n] are HP[2*n] and HP[2*n+1] ; HP[0] is not used.
			// ---
			hLen = 0;
			h = callee.HEAP_SIZE;
			for( c=i=-1 ; ++i < n ; Dyn[i].fc ? (DP[HP[++hLen]=c=i]=0) : (Dyn[i].dl=0) );

			// "The pkzip format requires that at least one distance code exists,
			// and that at least one bit should be sent even if there is only one
			// possible code. So to avoid special checks later on we force at least
			// two codes of nonzero frequency."
			// ---
			for( o=this.GBIT ; hLen < 2 ; )
			{
				Dyn[i = HP[++hLen] = 2 > c ? ++c : 0].fc = 1;
				DP[i] = 0;
				o.OPT_LEN--;
				Sta && (o.STAT_LEN -= Sta[i].dl);
			}

			desc.maxcode = c;

			// The elements HP[heap_len/2+1 .. heap_len] are leaves,
			// establish sub-heaps of increasing lengths.
			// ---
			for( i = hLen >> 1 ; i >= 1 ; this.DOWN(Dyn,i--,HP,DP,hLen) );

			// Construct the Huffman tree by repeatedly combining the
			// least two frequent nodes. [REM] The index of the
			// smallest element is 1.
			// ---
			do
			{
				i = HP[1];
				HP[1] = HP[hLen--];
				this.DOWN(Dyn,1,HP,DP,hLen);
				j = HP[1];
				HP[--h] = i;
				HP[--h] = j;
				Dyn[n].fc = Dyn[i].fc + Dyn[j].fc;
				DP[n] = DP[i] > 1+DP[j] ? DP[i] : (1+DP[j]);
				Dyn[i].dl = Dyn[j].dl = n;
				HP[1] = n++;
				this.DOWN(Dyn,1,HP,DP,hLen);
			}
			while( hLen >= 2 );

			HP[--h] = HP[1];
			this.GCOD(Dyn, c, this.GBIT(desc,HP,h));
		}
		.setup({ HEAP_SIZE:-1, HEAP:false, DEPTH:false }), // Fed from onEngine

		SCAN: function(/*tree&*/T,/*int*/maxCode,  nx,pv,mx,mn,k36,k3A,k11,BT,n,i,cur)
		//----------------------------------
		// (Scan-Tree.) Scan a literal or distance tree to determine the frequencies
		// of the codes in the bit length tree. Updates the opt. len to take into
		// account the repeat counts. (The contribution of the bit length codes will
		// be added later during the construction of BL tree.)
		// => undef
		{
			(nx=T[0].dl) ? ((mx=7),(mn=4)) : ((mx=138),(mn=3));
			T[1+maxCode].dl = 0xFFFF; // guard

			k36 = this.ZR36; // 16
			k3A = this.ZR3A; // 17
			k11 = this.ZR11; // 18

			for( BT=this.FLSH.BL_DESC.dyna, n=0, pv=i=-1 ; ++i <= maxCode ; )
			{
				cur = nx;
				nx = T[1+i].dl;
				if( ++n < mx && cur == nx ) continue;
				
				if( n < mn )
				{
					BT[cur].fc += n;
				}
				else if( cur )
				{
					cur != pv && BT[cur].fc++;
					BT[k36].fc++;
				}
				else
				{
					BT[n <= 10 ? k3A : k11].fc++;
				}

				n = 0;
				pv = cur;
				mn = 3;
				mx = (0==nx)*138 || (cur==nx)*6 || (++mn,7);
			}
		},

		FREQ: function(/*int|0*/dist,/*int*/lc,  F,LD,DD,osz,isz,c,n,a,dyn)
		//----------------------------------
		// (Tally-Frequencies.) Save the match info and tally the frequency counts.
		// Return true if the current block has to be flushed.
		// `lc` :: (match length - MIN_MATCH), or unmatched char if dist==0.
		// => bool
		{
			F = this.COMP;
			
			LD = this.FLSH.LI_DESC;
			DD = this.FLSH.DI_DESC;

			callee.LITR_BUF[callee.LAST_LITR++] = lc;
			if( 0 == dist )
			{
				LD.dyna[lc].fc++;                   // lc is the unmatched char
			}
			else 
			{
				// Here, lc is the match length - MIN_MATCH.
				// ---
				dist--;                           // dist = match distance - 1
				LD.dyna[ this.DLIT+F.LENG_CODE[lc] ].fc++;
				DD.dyna[ 255&F.DIST_CODE[256>dist?dist:(256+(dist>>7))] ].fc++;

				callee.DIST_BUF[callee.LAST_DIST++] = dist;
				callee.FLAG_VAL |= callee.FLAG_BIT;
			}

			callee.FLAG_BIT <<= 1;
			
			// Output the flags if they fill a byte.
			// ---
			(7&callee.LAST_LITR) || ((callee.FLAGS[callee.LAST_FLAG++]=callee.FLAG_VAL),(callee.FLAG_VAL=0),(callee.FLAG_BIT=1));

			// Try to guess if it is profitable to stop
			// the current block here.
			// [REM] TRY_GUESS is set to (2 < level).
			// ---
			if( callee.TRY_GUESS && !(0xFFF&callee.LAST_LITR) )
			{
				// Compute an upper bound for the compressed length.
				// ---
				isz = this.FILL.IDX - this.FILL.START;
				for( dyn=DD.dyna, osz=8*callee.LAST_LITR, n=F.DB_DIM, a=F.X_DIST, c=-1 ; ++c < n ; osz += dyn[c].fc*(5+a[c]) );
				osz >>= 3;
				
				// In           :: isz  ; Out          :: osz
				// Percentage   :: 100-(osz*100/isz)
				// ---
				if( osz < parseInt(isz/2,10) && callee.LAST_DIST < parseInt(callee.LAST_LITR/2,10) ) return true;
			}

			return (callee.LAST_LITR == -1+(n=callee.DDIM)) || (n == callee.LAST_DIST);
		}
		.setup(
		{
			TRY_GUESS: true,
			// ---
			DDIM:      -1,
			DIST_BUF:  false,
			LITR_BUF:  false,
			FLAGS:     false,
			// ---
			FLAG_BIT:  -1,
			LAST_DIST: -1,
			LAST_LITR: -1,
			LAST_FLAG: -1,
		}), // fed from DEFL

		COMP: function(/*obj&*/LT,/*obj&*/DT,  LL,DB,DC,LB,LC,XL,XD,lbf,dbf,fgs,lx,dx,fx,fg,d,i,c,x)
		//----------------------------------
		// (Compress-Block.) Send the block data compressed using the given Huf-trees.
		{
			if( !(LL=this.FREQ.LAST_LITR) ){ this.SNDB(LT[256]); return; } // End block

			DB = callee.DIST_BASE;
			DC = callee.DIST_CODE

			LB = callee.LENG_BASE;
			LC = callee.LENG_CODE;

			XD = callee.X_DIST;
			XL = callee.X_LENG;
			
			lbf = this.FREQ.LITR_BUF;
			dbf = this.FREQ.DIST_BUF;
			fgs = this.FREQ.FLAGS;
			lx = dx = fx = fg = 0;
			do
			{
				(7&lx) ? (fg >>= 1) : (fg=fgs[fx++]);

				i = 0xFF&lbf[lx++];

				// Send a literal byte?
				// ---
				if( !(1&fg) ){ this.SNDB(LT[i]); continue; }

				// Here i is the match length - MIN_MATCH.
				// ---
				this.SNDB( LT[this.DLIT+(c=LC[i])] );                    // send the length code.
				(x=XL[c]) && this.SNDB(i-=LB[c], x);                // extra length bits?

				d = dbf[dx++];                                      // send the distance code.
				this.SNDB( DT[c=0xFF&(256>d?DC[d]:DC[256+(d>>7)])] );
				(x=XD[c]) && this.SNDB(d-=DB[c], x);                // extra distance bits?
			}
			while( lx < LL );

			this.SNDB(LT[256]); // End block
		}
		.setup(
		{
			// ExtraLength and ExtraDistance bits.
			// ---
			X_DIST: Array( 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ),
			X_LENG: Array( 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ),

			// Extra BL-Bits.
			// ---
			X_BL:   Array( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ),

			// Other constant data -- fed from onEngine.
			// ---
			DIST_BASE:false, DB_DIM:30, DIST_CODE:false,             // Distance codes.
			LENG_BASE:false, LB_DIM:29, LENG_CODE:false, LC_OFF:-1,  // Length codes.
		}),

		FLSH: function(/*int*/eof,/*fct*/FW,  BO,LD,DD,BD,d,i,mx,no,ns,c0,c1,t,w,a)
		//----------------------------------
		// (Flush-Block.) Determine the best encoding for the current block
		// (dynamic trees, static trees, or store) and output the encoded
		// block.
		// => undef
		{
			BO = this.BLOR;
			LD = callee.LI_DESC;
			DD = callee.DI_DESC;
			BD = callee.BL_DESC;

			d = FW.IDX - FW.START;                      // Length of input block.

			this.FREQ.FLAGS[this.FREQ.LAST_FLAG] = this.FREQ.FLAG_VAL;// Save the flags for the last 8 items.
			this.HUFF(LD);                                            // Construct the literal tree.
			this.HUFF(DD);                                            // Construct the distance tree.

			// At this point, the opt. length and static length
			// are the total bit lengths of the compressed block data,
			// excl. the tree representations.
			
			// Construct the Huffman tree for the 'bit lengths' for the above
			// two trees, and get the Bit-Length order of the last BL code to send.

			this.SCAN(LD.dyna, LD.maxcode);             // Bit length frequency in literal tree.
			this.SCAN(DD.dyna, DD.maxcode);             // Bit length frequency in dist. tree.
			this.HUFF(BD);                                // Bit length descriptor.

			// ---
			// [REM] Opt. length now includes the length of the tree
			// representations, except the lengths of the
			// bit lengths codes and the 5+5+4 bits for the counts.
			// ---

			// Determine the number of bit length codes to send.
			// "The pkzip format requires that at least 4 bit length codes
			// be sent. (appnote.txt says 3 but the actual value used is 4.)"

			for( a=BD.dyna, i=-1+this.BLSZ ; i >= 3 && !(a[BO[i]].dl) ; i-- );
			t = (this.GBIT.OPT_LEN += (3*(1+i)+14)); // Update opt len to include the BL tree and counts.
			mx = i;

			// Determine the best encoding. Compute first the block
			// length in bytes.
			( (ns=(10+this.GBIT.STAT_LEN)>>3) <= (no=(10+t)>>3) ) && (no=ns);

			if( d+4 <= no && FW.START >= 0 )          // Two words (+4) for the lengths.
			{
				// STORE block type.
				// ---
				this.SNDB((this.ESTO << 1) + eof, 3);
				
				// Align on byte boundary.
				// ---
				0 >= (t=this.SNDB).BSHIFT || ( 8 < t.BSHIFT ? this.OUTS : this.OUTB )(t.BBUF);
				t.BBUF = t.BSHIFT = 0;

				this.OUTS(d);
				this.OUTS(~d);
				
				// Copy block.
				// ---
				for( w=FW.WIN, t=FW.START, i=-1 ; ++i < d ; this.OUTB(w[t+i]) );
			}
			else if( ns == no )
			{
				// STATIC block type.
				// ---
				this.SNDB((this.ESTA << 1) + eof, 3);
				this.COMP(LD.stat, DD.stat);
			}
			else 
			{
				// DYNAMIC block type.
				// ---
				this.SNDB((this.EDYN << 1) + eof, 3);
				// ---
				// Send the header using dynamic Huffman trees: counts
				// lengths of the bit length codes, literal and dist. trees.
				// ---
				c0 = LD.maxcode;                                   // c0 >= 256
				c1 = DD.maxcode;                                   // c1 >= 0
				this.SNDB(-256+c0, 5).SNDB(c1, 5).SNDB(-3+mx, 4);     // mx >= 3
				for( a=BD.dyna, i=-1 ; ++i <= mx ; this.SNDB(a[BO[i]].dl, 3) );
				this.SEND( LD.dyna, c0, BD.dyna );
				this.SEND( DD.dyna, c1, BD.dyna );
				// ---
				this.COMP(LD.dyna, DD.dyna);
			}

			this.IBLK(LD,DD,BD);

			if( !eof ) return;
			
			// Align on byte boundary.
			// ---
			//0 >= (t=this.SNDB).BSHIFT || ( 8 < t.BSHIFT ? this.OUTS : this.OUTB )(t.BBUF);
			0 >= (t=this.SNDB).BSHIFT || this[ 8 < t.BSHIFT ? 'OUTS' : 'OUTB' ](t.BBUF);
			t.BBUF = t.BSHIFT = 0;
		}
		.setup(
		{
			LI_DESC: { dyna:false, stat:false, xbits:false, xbase:0, items:0, maxlen:0, maxcode:0 },
			DI_DESC: { dyna:false, stat:false, xbits:false, xbase:0, items:0, maxlen:0, maxcode:0 },
			BL_DESC: { dyna:false, stat:false, xbits:false, xbase:0, items:0, maxlen:0, maxcode:0 },
		}),

		FAST: function(/*fct&*/FW,/*uint*/match,/*cnst*/mMIN,/*cnst*/mxDIST,/*cnst*/mxLAZY,/*fct*/fHash,  w,dic,fIns,lka,id,hh,t)
		//----------------------------------
		// (Deflate-Fast.) Processes a new input file.
		// This function does not perform lazy evaluation of matches and inserts new
		// strings in the dictionary only for unmatched strings or for short matches.
		// It is used only for the fast compression options.
		// => uint
		{
			w = FW.WIN;
			dic = FW.PRV;
			fIns = this.INSH;

			while( (lka=FW.LOOK) && !this.OUTB.HEAD )
			{
				// Insert the string window[strstart .. strstart+2] in the
				//  dictionary, and set hash head to the head of the hash chain.
				// ---
				hh = fIns(w,dic,id=FW.IDX,fHash);

				// To simplify the code, we prevent matches with the string
				// of window index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).
				// ---
				if( hh != 0 && id - hh <= mxDIST )
				{
					match = this.MTCH(hh,this.DINT.PREV_LEN,mxDIST,FW); // update this.DINT.MATCH_START
					match > lka && (match=lka);
				}

				if( match >= mMIN )
				{
					t = this.FREQ(id - this.DINT.MATCH_START, match - mMIN);
					lka -= match;
					
					// Insert new strings in the hash table only if the match
					// length is not too large. Saves time but degrades compression.
					// ---
					if( match <= mxLAZY )
					{
						match--;
						do{ ++id; fIns(w,dic,id,fHash); } while( --match );
						++id;
					}
					else 
					{
						id += match;
						match = 0;
						fIns.POS = fHash(0xFF&w[id], w[1+id]);
					}
				}
				else 
				{
					t = this.FREQ(0, 0xFF&w[id]);
					--lka;
					++id;
				}

				t && (this.FLSH(0,FW),(FW.START=id));

				// Make sure that we always have enough lookahead, except
				// at the end of the input file. We need MAX_MATCH bytes
				// for the next match, plus MIN_MATCH bytes to insert the
				// string following the next match.

				FW.LOOK = lka;
				this.DINT.MATCH_START = FW(id,this.READ,this.DINT.MATCH_START);
			}
			return match;
		},

		BTTR: function(/*fct&*/FW,/*uint*/match,/*cnst*/mMIN,/*cnst*/mxDIST,/*cnst*/mxLAZY,/*fct*/fHash,  w,dic,fIns,prev,far,lka,id,hh,t,p)
		//----------------------------------
		// (Deflate-Better.)
		// => uint
		{
			w = FW.WIN;
			dic = FW.PRV;

			fIns = this.INSH;
			prev = false;
			far = callee.TOO_FAR;
			while( (lka=FW.LOOK) && !this.OUTB.HEAD )
			{
				hh = fIns(w,dic,id=FW.IDX,fHash);

				// Find the longest match, discarding those <= prev_length.
				// ---
				prev = match;
				p = this.DINT.MATCH_START;
				match = mMIN - 1;
				if( hh != 0 && prev < mxLAZY && id - hh <= mxDIST )
				{
					match = this.MTCH(hh,prev,mxDIST,FW); // change this.DINT.MATCH_START
					match > lka && (match=lka);
					
					// Ignore a length 3 match if it is too distant:
					// If prev_match is also MIN_MATCH, match_start is
					// garbage but we will ignore the current match anyway.
					// ---
					match == mMIN && (id-this.DINT.MATCH_START > far) && match--;
				}

				// If there was a match at the previous step and the
				// current match is not better, output the previous match.
				// ---
				if( prev >= mMIN && match <= prev )
				{
					t = this.FREQ(-1+id-p, prev-mMIN);
					
					// Insert in hashtable all strings up to the end of
					// the match (id-1 and id are already inserted.)
					// ---
					lka -= (-1+prev);
					prev -= 2;
					
					// [REM] id never exceeds WSIZE-MAX_MATCH, so there
					// are always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
			 		// these bytes are garbage, but it does not matter since the
					// next lookahead bytes will always be emitted as literals.
					// ---
					do{ id++; fIns(w,dic,id,fHash); }while( --prev );

					this.DINT.MATCHED = false;
					match = mMIN - 1;
					++id;
					t && (this.FLSH(0,FW),(FW.START=id));
				}
				else if( this.DINT.MATCHED )
				{
					// If there was no match at the previous position, output a
					// single literal. If there was a match but the current match
					// is longer, truncate the previous match to a single literal.
					// ---
					this.FREQ(0, 255&w[-1+id]) && (this.FLSH(0,FW),(FW.START=id));
					++id;
					--lka;
				}
				else 
				{
					// There is no previous match to compare with, wait for
					// the next step to decide.
					// ---
					this.DINT.MATCHED = true;
					++id;
					--lka;
				}

				FW.LOOK = lka;
				this.DINT.MATCH_START = FW(id,this.READ,this.DINT.MATCH_START);
			}
			
			false===prev || (this.DINT.PREV_LEN=prev);
			return match;
		}
		.setup({ TOO_FAR: -1 }), // fed from DEFL

		DINT: function(/*arr&*/buf,/*int*/off,/*int*/bfSize,/*1..9*/level,  FW,DSC,w,mn,a,n,i,c,d,f,o,p)
		//----------------------------------
		// (Deflate-Internal.)
		// => int
		{
			w = (FW=this.FILL).WIN;

			if( !callee.INI_DONE )
			{
				if( !FW.EOF )
				{
					mn = -1+this.MMIN;
					this.SNDB.BBUF = this.SNDB.BSHIFT = 0;

					this.FLSH.DI_DESC.stat || this.IBLK(false);

					// Not needed (and time consuming!)
					// for( a=FW.PRV, p=this.WMEM, n=FW.H_SIZE, i=-1 ; ++i < n ; a[i+p]=0 );

					o = callee.CONFIG[level];
					callee.MAX_LAZY = o.lazy;
					this.MTCH.GOOD = o.good;
					this.FULL || (this.MTCH.NICE=o.nice);
					this.MTCH.MAX_CHAIN_LEN = o.chain;

					FW.IDX = FW.START = 0;
					if( FW.EOF = 0 >= (FW.LOOK=this.READ(w, 0, FW.WDIM)) )
					{
						FW.LOOK = 0;
					}
					else
					{
						FW(0,this.READ);
						for( p=0, n=mn, i=-1 ; ++i < n ; p=this.HASH(p,w[i]) );
						this.INSH.POS = p;
					}

					this.OUTB.HEAD = this.OUTB.TAIL = false;
					this.OUTB.POS = this.OUTB.OFF = 0;
					3 >= level ?
						( (callee.PREV_LEN=mn),(callee.MATCH_LEN=0) ) :
						( (callee.MATCH_LEN=mn),(callee.MATCHED=false) );
					callee.COMPLETED = false;
				}

				callee.INI_DONE = true;
				if( !FW.LOOK ){ callee.COMPLETED = true; return 0; }
			}

			n = this.QCPY(buf, off, bfSize);
			if( bfSize == n ) return bfSize;
			if( callee.COMPLETED ) return n;

			callee.MATCH_LEN = this[3 >= level ? 'FAST' : 'BTTR']
				( FW, callee.MATCH_LEN, this.MMIN, callee.MAX_DIST, callee.MAX_LAZY, this.HASH );

			if( !FW.LOOK )
			{
				callee.MATCHED && this.FREQ(0, 255&w[-1+FW.IDX]);
				this.FLSH(1,FW);
				callee.COMPLETED = true;
			}

			return n + this.QCPY(buf, n + off, bfSize - n);
		}
		.setup({
			INI_DONE:  false,
			COMPLETED: false,
			MATCHED:   false,
			MATCH_LEN: 0,
			PREV_LEN:  0,
			MAX_DIST: -1, // fed by onEngine
			MATCH_START: -1,
			CONFIG: Array
			(
				{ good: 0, lazy:  0, nice:  0, chain:   0 }, // 0(noop)
				{ good: 4, lazy:  4, nice:  8, chain:   4 }, // Level 1
				{ good: 4, lazy:  5, nice: 16, chain:   8 }, // Level 2
				{ good: 4, lazy:  6, nice: 32, chain:  32 }, // Level 3
				{ good: 4, lazy:  4, nice: 16, chain:  16 }, // Level 4
				{ good: 8, lazy: 16, nice: 32, chain:  32 }, // Level 5
				{ good: 8, lazy: 16, nice:128, chain: 128 }, // Level 6
				{ good: 8, lazy: 32, nice:128, chain: 256 }, // Level 7
				{ good:32, lazy:128, nice:258, chain:1024 }, // Level 8
				{ good:32, lazy:258, nice:258, chain:4096 }  // Level 9
			),
			MAX_LAZY: -1,
		}),

		DEFL: function(/*str*/data,/*1..9*/level,/*uint*/litDim,/*0x2000|4000|8000*/bs,/*13|14|15*/hb,  F,t,i,j,r,a)
		//----------------------------------
		// (Deflate.)
		// level     :: Compression level.
		// litDim    :: Actual dim of the literal buffer.
		// bs        :: Buffer size (0x2000|0x4000|0x8000).
		// hb        :: Hash bits (related to bs.)
		// => str
		{
			// Data string.
			// ---
			(F=this.READ).DATA=data;
			F.POS=0;

			// Level-related settings.
			// ---
			this.FREQ.TRY_GUESS = 2 < level;

			// Out buffer dim.
			// ---
			if( (F=this.OUTB).OBUF ) return;
			F.ODIM = 0x2000; // Might change?
			F.FREE = F.HEAD = F.TAIL = false;
			F.OBUF = Array(F.ODIM);

			// Initial conditions and sliding window.
			// ---
			this.DINT.INI_DONE = false;
			(F=this.FILL).EOF = false;
			F.WIN = Array(F.WDIM);
			F.PRV = Array(1 << callee.BITS);

			// Literal and distance buffer.
			// ---
			this.FILL.H_SIZE = 1 << hb;
			this.BTTR.TOO_FAR = 0x1000;     // 'Too far' distance within the buffer ; may we use bs>>>2 instead??
			this.HASH.MASK = -1 + this.FILL.H_SIZE;
			this.HASH.SHFT = parseInt((hb + this.MMIN - 1) / this.MMIN, 10);
			// ---
			(F=this.FREQ).DDIM = bs;
			F.DIST_BUF = Array(bs);
			F.LITR_BUF = Array(litDim);
			F.FLAGS    = Array(parseInt(bs/8),10);

			const CHR = String.fromCharCode;
			for( r='', a=Array(1024) ; 0 < (i=this.DINT(a,0,a.length,level)) ; )
			{
				for( j=-1 ; ++j < i ; r += CHR(a[j]) );
			}


			// Cleanup.
			// ---
			this.FREQ.DIST_BUF = this.FREQ.LITR_BUF = this.FREQ.FLAGS = false;
			this.IDSC(this.FLSH.LI_DESC)(this.FLSH.DI_DESC)(this.FLSH.BL_DESC);      // Cleanup descriptors and inner trees.
			this.FILL.WIN  = this.FILL.PRV  = false;
			this.OUTB.HEAD = this.OUTB.TAIL = this.OUTB.FREE = false;
			this.OUTB.OBUF = false;
			this.READ.DATA = '';

			return r;
		}
		.setup({ BITS:16 }),

	})

	//==========================================================================
	// API
	//==========================================================================

	[PUBLIC]
	
	({

		onEngine: function onEngine_(  I,F,DB,DC,LB,LC,a,i,c,d,n)
		// ---------------------------------
		{
			I = callee.µ['~'];
			
			// Feed constant arrays once for all.
			//----------------------------------
			F = I.COMP;
			DB = F.DIST_BASE = Array(F.DB_DIM);             //  30
			DC = F.DIST_CODE = Array(512);                  // 512
			LB = F.LENG_BASE = Array(F.LB_DIM);             //  29
			LC = F.LENG_CODE = Array(1+258-I.MMIN);         // 256

			a = F.X_LENG;
			for( d=F.LB_DIM-1, i=c=0 ; c < d ; ++c )
				for( LB[c]=i, n=1<<a[c] ; n-- ; LC[i++]=c );

			a = F.X_DIST;
			for( LC[-1+i]=c, d=0, c=-1 ; ++c < 16 ; )
				for( DB[c]=d, n=1<<a[c] ; n-- ; DC[d++]=c );
			for( d >>= 7 ; c < F.DB_DIM ; c++ )
				for( DB[c]=d<<7, n=1<<a[c]-7 ; n-- ; DC[256 + d++]=c );

			// Some constant scalars.
			//----------------------------------
			n = F.LC_OFF = I.DLIT + F.LB_DIM;               // L-Codes offset.
			I.FILL.MIN_LOOK = 1+258 + I.MMIN;               // Min. match lookahead.
			I.DINT.MAX_DIST = I.WMEM - I.FILL.MIN_LOOK;     // Max. match distance.
			I.FILL.IDX_MAX  = I.WMEM + I.DINT.MAX_DIST;     // Max. index.
			
			// Heap structure.
			//----------------------------------
			n = 1+2*n;
			(F=I.HUFF).HEAP_SIZE = n;                       // Heap size.
			F.HEAP  = Array(n);                             // Heap.
			F.DEPTH = Array(n);                             // Depth array.
		},

		run: function run_S_i_i_i_S(/*str*/data,/*?(1..9)=6*/level,/*16..64=32*/inKB,/*0|1|2=0*/bufCapa,  I,bs,hb,inSz,bits)
		//----------------------------------
		// `level`   :: Compression level (1..9) ; default: 6.
		// `inKB`    :: Size in KB of the input buffer (16..64) ; default: 32.
		// `bufCapa` :: 0(small) | 1(medium) | 2(big)
		// => str
		{
			I = callee.µ['~'];
			
			'string' == typeof data || (data=String(data));

			// WMEM = 2^15 ; WDIM = 2*WMEM = 2^16 => bits >= 16  (since 2^bits must >= WDIM.)
			// May we change BITS?
			// ---
			I.DEFL.BITS = bits = 16;

			// Normalize args.
			// ---
			1 > (level|=0) ? (level=6) : ( 9 < level && (level=9) );            // 1 <= (level=6) <= 9
			8 > (inKB|=0)  ? (inKB=32) : ( 64 < inKB && (inKB=64) );            // 8 <= (inKB=32) <= 64
			1 > (bufCapa|=0) ? (bufCapa=0) : ( 1 < bufCapa && (bufCapa=2) );    // 0(small) | 1(medium) | 2(big)

			// Literal and distance buffer dim.
			// ---                                                              // SMALL      | MEDIUM      | BIG
			bs = [0x2000,0x4000,0x8000][bufCapa];                               // 0x2000(8K) | 0x4000(16K) | 0x8000(32K)
			// --- Hash bits ( 8 <= hb < callee.BITS )
			hb = [13,14,15][bufCapa];                                           // 13         | 14          | 15
			// ---
			inSz = 1024*inKB;

			// Assertions.
			// ---
			bs <= inSz
			|| $.global[callee.µ.__root__].error(__("Input buffer too small (%1). Should be at least %2KB.",inSz,bs/1024));

			I.WMEM <= (1 << (bits-1))
			|| $.global[callee.µ.__root__].error(__("Window memory too large (%1). Should be at most %2.",I.WMEM,(1 << (bits-1))));

			( hb < bits && hb >= 8 )
			|| $.global[callee.µ.__root__].error(__("Invalid bit capacity (%1). Should be between 8 and %2.",hb,bits-1));

			// Literal buffer dim is: inSz + 64 extra positions.
			// ---
			return I.DEFL(data,level,64+inSz,bs,hb);
		},

		zlib: function zlib_S_S(/*str*/data,  adlr)
		//----------------------------------
		// [ADD190420] Deflate (compress) data in zlib wrapper.
		// [REF] tools.ietf.org/html/rfc1950
		{
			'string' == typeof data || (data=String(data));
			
			// Adler32 suffix.
			// ---
			adlr = callee.µ['~'].ADLR(data);
			adlr = String.fromCharCode( adlr>>>24, 0xFF&(adlr>>>16), 0xFF&(adlr>>>8), 0xFF&(adlr>>>0) );

			// Default compression.
			// ---
			data = callee.µ.run( data );

			// Zlib headers:
			// ---
			// 78 01 - No Compression/low
			// 78 9C - Default Compression
			// 78 DA - Best Compression 

			return '\x78\x9C' + data + adlr;
		},
	})

